# 開発ワークフロー改善ガイドライン

このドキュメントは、開発作業を効率的かつ効果的に進めるためのガイドラインをまとめたものです。特に、作業範囲の管理とコミット戦略に焦点を当てています。

## 1. 指示範囲の明確化と遵守

### 問題点
- 指示された範囲を超えて作業を進めてしまう（スコープクリープ）
- 明示的な承認なしに追加機能を実装してしまう

### 改善策
- **作業開始前の確認**：タスクの範囲と目標を明確に理解し、必要に応じて質問する
- **段階的な承認**：指示された範囲を完了したら、次のステップに進む前にユーザーの承認を得る
- **提案ベースの拡張**：追加作業が有益と判断した場合は、実装ではなく提案として提示する
- **明示的な境界設定**：「このタスクには含まれないもの」を明確にする

### 実践方法
```
# 良い例
「開発環境のセットアップが完了しました。次のステップとして、基本コンポーネントの実装を行いますか？」

# 悪い例
「開発環境のセットアップが完了したので、続けて基本コンポーネントも実装しました」
```

## 2. 論理的な単位でのコミット戦略

### 問題点
- 大きな変更を一度にコミットしてしまう
- 関連性の低い変更を同じコミットに含めてしまう
- コミット履歴から作業の流れが追跡しにくくなる
- **変更後のコミットを忘れてしまう**

### 改善策
- **アトミックコミット**：1つの論理的な変更に対して1つのコミットを作成する
- **段階的なコミット**：大きな機能は複数の小さなコミットに分割する
- **明確なコミットメッセージ**：何が、なぜ変更されたのかを簡潔に説明する
- **コミットの事前確認**：コミット前に変更内容を確認し、不要な変更や一時ファイルを除外する
- **コミット習慣の定着**：変更完了後は必ずコミットを行うチェックリストを作成し、遵守する

### コミット単位の例
1. **プロジェクト初期化**：基本設定ファイルの作成
2. **依存関係の追加**：必要なパッケージのインストール
3. **設定ファイルの更新**：特定の機能のための設定変更
4. **コンポーネント単位**：各UIコンポーネントの追加や修正
5. **機能単位**：特定の機能（認証、データ取得など）の実装
6. **バグ修正**：特定の問題の解決
7. **リファクタリング**：コードの改善（機能変更なし）
8. **ドキュメント更新**：コメントやREADMEの更新

### コミット前チェックリスト
- [ ] 変更内容が1つの論理的な単位になっているか
- [ ] 変更内容が意図した通りになっているか
- [ ] 不要なファイルやデバッグコードが含まれていないか
- [ ] コミットメッセージは変更内容と理由を明確に説明しているか
- [ ] 適切なプレフィックス（feat:, fix:, docs:など）を使用しているか

### 実践方法
```bash
# 良い例
git add package.json package-lock.json
git commit -m "chore: プロジェクト依存関係の追加"

git add tailwind.config.js
git commit -m "config: Tailwind CSSの設定"

git add src/components/Button.tsx
git commit -m "feat: ボタンコンポーネントの実装"

# 悪い例
git add .
git commit -m "いろいろ実装"
```

## 3. 進捗報告と承認フロー

### 問題点
- 長時間作業後に一度に大量の変更を報告する
- ユーザーが途中経過を確認できない
- 方向性の誤りが後になって発覚する

### 改善策
- **マイルストーン報告**：主要な機能や段階が完了したら報告する
- **定期的な状況共有**：長時間の作業中も定期的に進捗を共有する
- **決定ポイントの明確化**：ユーザーの判断が必要な箇所を特定し、明示的に質問する
- **視覚的な確認**：可能な場合はスクリーンショットや図を使って進捗を示す

### 実践方法
```
# 良い例
「環境構築の第一段階（Next.jsプロジェクトの作成とTailwind CSSの設定）が完了しました。
以下が現在の状態です：
- package.jsonに必要な依存関係を追加しました
- tailwind.config.jsを設定しました
次のステップとして、Biomeの設定を行ってよろしいですか？」

# 悪い例
「すべての環境構築が完了しました。何か質問はありますか？」
```

## 4. 作業の文書化

### 問題点
- 実装の意図や決定理由が不明確
- 後から作業内容を振り返りにくい
- 他の開発者が変更の背景を理解しにくい

### 改善策
- **コミットメッセージの充実**：変更内容だけでなく、なぜその変更を行ったかも記録する
- **重要な決定の文書化**：技術選定や設計判断の理由をコメントやドキュメントに残す
- **メモリバンクの更新**：作業完了後にメモリバンクを更新し、現在の状態を反映させる
- **TODO/FIXMEコメント**：将来的な改善点や注意点をコード内にマークする

### 実践方法
```
# 良いコミットメッセージの例
feat: 日本語タグ対応の正規表現を修正

英数字のみ対応だった正規表現(/#(\w+)/g)を、
日本語を含む多言語対応(/#([^\s#]+)/g)に変更。
これにより、日本語のタグも正しく認識されるようになる。
```

## 5. タスク開始時の要件確認プロセス

### 問題点
- 要件の理解が不十分なまま実装を開始してしまう
- プラットフォーム固有の動作要件を見落とす
- 実装後に要件の変更や修正が必要になる

### 改善策
- **詳細な要件確認**：タスク開始前に要件の詳細を確認する
- **プラットフォーム固有の要件確認**：Mac/Windows/Linuxなど、プラットフォーム固有の動作要件を明確にする
- **ブラウザ固有の要件確認**：Chrome/Firefox/Safariなど、ブラウザ固有の動作要件を明確にする
- **理解の共有**：自分の理解を明確に伝え、確認を取る

### 要件確認チェックリスト
- [ ] タスクの目的を明確に理解している
- [ ] 実装すべき機能の詳細を確認した
- [ ] プラットフォーム固有の要件を確認した（Mac/Windows/Linuxなど）
- [ ] ブラウザ固有の要件を確認した（Chrome/Firefox/Safariなど）
- [ ] エッジケースや例外処理の要件を確認した

### 実践方法
```
# 要件確認テンプレート
「〇〇機能について、以下の理解で合っていますか？
- 機能A: 〜〜のように動作する
- 機能B: 〜〜の場合は〜〜、〜〜の場合は〜〜となる
- プラットフォーム固有の動作: Macでは〜〜、Windowsでは〜〜
実装を進める前に、上記の理解で問題ないか確認させてください。」

# 具体例（キーボードショートカット機能の場合）
「メッセージ送信のショートカットキー変更について、以下の理解で合っていますか？
- Macでは⌘+Enterキーでメッセージを送信
- Windowsではctrl+Enterキーでメッセージを送信
- 通常のEnterキーは改行として機能する
実装を進める前に、上記の理解で問題ないか確認させてください。」
```

## 6. 実装・テスト・報告サイクル

### 問題点
- 実装後のテストが不十分
- 変更内容の報告が不明確
- 複数環境での動作確認が行われない

### 改善策
- **段階的な実装**：小さな単位で実装し、各ステップで確認する
- **テスト検証の徹底**：複数の環境で動作確認を行う
- **明確な変更報告**：変更内容と変更理由を明確に説明する
- **エッジケースの考慮**：通常の使用パターン以外のケースも考慮する

### テスト検証チェックリスト
- [ ] 基本機能が意図通りに動作する
- [ ] 複数のブラウザで動作確認した
- [ ] 複数のプラットフォームで動作確認した
- [ ] エッジケースでも正しく動作する
- [ ] パフォーマンスに問題がない

### 実践方法
```
# 変更報告テンプレート
「〇〇機能の実装が完了しました。

【変更内容】
1. 〇〇ファイルの〇〇関数を修正し、〇〇の動作を実現
2. 〇〇コンポーネントに〇〇のUIを追加

【変更理由】
- 〇〇の問題を解決するため
- 〇〇の使い勝手を向上させるため

【テスト結果】
- Mac Chrome: 正常に動作
- Windows Firefox: 正常に動作
- エッジケース（〇〇の状況）: 期待通りに動作

次のステップとして、〇〇の実装を進めてよろしいでしょうか？」

# 具体例（キーボードショートカット機能の場合）
「メッセージ送信のショートカットキー変更が完了しました。

【変更内容】
1. MessageInput.tsxのhandleKeyDown関数を修正し、⌘+Enter/Ctrl+Enterでメッセージを送信するように変更
2. ヘルプテキストを「⌘+Enter / Ctrl+Enterで送信」に更新

【変更理由】
- ユーザーがより直感的にメッセージを送信できるようにするため
- プラットフォーム固有のショートカットキーに対応するため

【テスト結果】
- Mac Chrome: ⌘+Enterで正常に送信される
- Windows Chrome: Ctrl+Enterで正常に送信される
- 通常のEnterキー: 改行として機能する

変更内容をコミットしてよろしいでしょうか？」
```

## 7. タスク完了基準

### 問題点
- タスクの完了基準が不明確
- 必要な作業が漏れる
- コミットを忘れる
- 学びや改善点が記録されない

### 改善策
- **完了基準の明確化**：タスクが完了したと見なすための条件を明確にする
- **最終確認チェックリスト**：タスク完了前に確認すべき項目をリスト化する
- **振り返りと改善**：タスク完了後に振り返りを行い、改善点を記録する
- **メモリバンクの更新**：学びや改善点をメモリバンクに記録する

### タスク完了チェックリスト
- [ ] 要件に沿った実装が完了している
- [ ] テスト検証が完了している
- [ ] コードの品質に問題がない
- [ ] 変更内容をコミットしている
- [ ] 必要に応じてメモリバンクを更新している
- [ ] タスクの振り返りを行い、学びや改善点を記録している

### 実践方法
```
# タスク完了報告テンプレート
「〇〇タスクが完了しました。

【完了した作業】
1. 〇〇機能の実装
2. テスト検証
3. コミット（コミットメッセージ: "〇〇"）

【確認事項】
- 要件に沿った実装: ✅
- テスト検証: ✅
- コードの品質: ✅
- コミット: ✅

次のタスクに進んでよろしいでしょうか？」
```

## 8. タスク完了後の振り返りプロセス

### 問題点
- タスク完了後に学びや改善点が記録されない
- 同じ問題が繰り返し発生する
- 効果的なアプローチが共有されない

### 改善策
- **タスク振り返りの実施**：タスク完了後に振り返りを行い、学びや改善点を記録する
- **メモリバンクの更新**：振り返りの内容をメモリバンクに反映させる
- **ユーザーへの確認**：振り返り作業を行うかどうかをユーザーに確認する

### 振り返りの観点
- **成功した点**：うまくいった点、効果的だった手法
- **改善できる点**：次回同様のタスクで改善できる点
- **学んだこと**：タスクから得られた新しい知見や気づき
- **今後の対応**：今回の学びを今後どのように活かすか

### 実践方法
```
# タスク振り返りテンプレート
「今回のタスクを振り返って、以下の点が挙げられます：

【成功した点】
- 〇〇のアプローチが効果的だった
- 〇〇の実装方法がシンプルで分かりやすかった

【改善できる点】
- 〇〇の部分は、もっと〇〇な方法で実装できたかもしれない
- 〇〇の確認が不足していた

【学んだこと】
- 〇〇の技術について新しい知見を得た
- 〇〇のパターンが特定の状況で有効であることが分かった

【今後の対応】
- 〇〇の実装パターンをメモリバンクに記録する
- 〇〇の部分は次回から事前に確認するようにする

これらの学びをメモリバンクに反映させますか？」
```

## まとめ

効果的な開発ワークフローは、以下の原則に基づいています：

1. **明確な境界設定**：作業範囲を理解し、遵守する
2. **段階的な実装**：大きなタスクを小さな単位に分割する
3. **頻繁なコミュニケーション**：進捗を共有し、方向性を確認する
4. **論理的なコミット**：変更を意味のある単位でコミットする
5. **透明性の確保**：決定理由や実装意図を文書化する
6. **要件確認の徹底**：タスク開始前に詳細な要件を確認する
7. **テスト検証の徹底**：複数環境での動作確認を行う
8. **コミット習慣の定着**：変更完了後は必ずコミットを行う

これらの原則を守ることで、効率的で追跡可能な開発プロセスを実現し、品質の高いソフトウェアを提供することができます。
